/* Практическое задание по теме “Транзакции, переменные, представления”
1. В базе данных shop и sample присутствуют одни и те же таблицы, учебной базы данных. Переместите запись id = 1 из таблицы shop.users в таблицу sample.users. Используйте транзакции. */

START TRANSACTION;
INSERT INTO sample.users (name, birthday_at, created_at, updated_at) SELECT name, birthday_at, created_at, updated_at FROM shop.users WHERE id=1; 
-- копируем строку с ИД=1 из таблицы shop.users и вставляем в sample.users с новым ИД (если оставить ИД=1, то будет выведена ошибка)
-- если нужно удалить запись из shop.users, используем следующую строку
-- DELETE FROM shop.users WHERE id = 1;
COMMIT;
                                                                                                                                                                                                                                                                                                      

/* 2. Создайте представление, которое выводит название name товарной позиции из таблицы products и соответствующее название каталога name из таблицы catalogs. */

USE shop;
DROP VIEW IF EXISTS prod_cat;
CREATE VIEW prod_cat (products, catalogs) AS SELECT p.name, c.name FROM products p JOIN catalogs c ON c.id = p.catalog_id;
SELECT products, catalogs FROM prod_cat pc;


/* 3. (по желанию) Пусть имеется таблица с календарным полем created_at. В ней размещены разряженые календарные записи за август 2018 года '2018-08-01', '2016-08-04', '2018-08-16' и 2018-08-17. 
 * Составьте запрос, который выводит полный список дат за август, выставляя в соседнем поле значение 1, если дата присутствует в исходном таблице и 0, если она отсутствует. */

/* 4. (по желанию) Пусть имеется любая таблица с календарным полем created_at. Создайте запрос, который удаляет устаревшие записи из таблицы, оставляя только 5 самых свежих записей. */


/* Практическое задание по теме “Администрирование MySQL” (эта тема изучается по вашему желанию)
1. Создайте двух пользователей которые имеют доступ к базе данных shop. Первому пользователю shop_read должны быть доступны только запросы на чтение данных, 
второму пользователю shop — любые операции в пределах базы данных shop. */


/* 2. (по желанию) Пусть имеется таблица accounts содержащая три столбца id, name, password, содержащие первичный ключ, имя пользователя и его пароль. 
 * Создайте представление username таблицы accounts, предоставляющий доступ к столбца id и name. 
 * Создайте пользователя user_read, который бы не имел доступа к таблице accounts, однако, мог бы извлекать записи из представления username. */



/* Практическое задание по теме “Хранимые процедуры и функции, триггеры"
1. Создайте хранимую функцию hello(), которая будет возвращать приветствие, в зависимости от текущего времени суток. 
С 6:00 до 12:00 функция должна возвращать фразу "Доброе утро", с 12:00 до 18:00 функция должна возвращать фразу "Добрый день", 
с 18:00 до 00:00 — "Добрый вечер", с 00:00 до 6:00 — "Доброй ночи". */
DROP FUNCTION IF EXISTS hello; 
DELIMITER //

CREATE FUNCTION hello(times TIME)
RETURNS TEXT NO SQL
BEGIN
	RETURN CASE
		WHEN times >= '06:00:00' AND times < '12:00:00' THEN 'Доброе утро'
		WHEN times >= '12:00' AND times < '18:00' THEN 'Добрый день'
		WHEN times >= '18:00' AND times < '23:60' THEN 'Добрый вечер'
		WHEN times >= '00:00' AND times < '06:00' THEN 'Доброй ночи'
	END;
END//
DELIMITER ;

SELECT hello('00:00') AS 'Приветствие';

SELECT hello(current_time()) AS 'Приветствие';



/* 2. В таблице products есть два текстовых поля: name с названием товара и description с его описанием. 
 * Допустимо присутствие обоих полей или одно из них. Ситуация, когда оба поля принимают неопределенное значение NULL неприемлема. 
 * Используя триггеры, добейтесь того, чтобы одно из этих полей или оба поля были заполнены. 
 * При попытке присвоить полям NULL-значение необходимо отменить операцию. */


/* 3. (по желанию) Напишите хранимую функцию для вычисления произвольного числа Фибоначчи. 
 * Числами Фибоначчи называется последовательность в которой число равно сумме двух предыдущих чисел. 
 * Вызов функции FIBONACCI(10) должен возвращать число 55. */

